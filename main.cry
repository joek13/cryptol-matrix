module Main where

/*
 * Proof of concept: basic matrix operations implemented in Cryptol.
 */

import Float

// Type definitions

type Float32 = Float 8 24
type Vec k a = [k]a
type Mat m n a = [m][n]a

type constraint Dim n = (fin n, n > 0)
type constraint Elem a = (Eq a, Ring a)

// Initializing vectors and matrices

full : { m, n, a } (Dim m, Dim n) => a -> Mat m n a
full v = repeat (repeat v)

zeros : { m, n, a } (Dim m, Dim n, Literal 0 a) => Mat m n a
zeros = full 0

diag : { m, n, a } (Dim m, Dim n, Literal 0 a) => a -> Mat m n a
diag v = [ [ if i == j then v else 0 | j <- [1..n] ] | i <- [1..m]]

id : { m, n, a } (Dim m, Dim n, Literal 0 a, Literal 1 a) => Mat m n a
id = diag 1

// Matrix operations

scale : { k, a } Ring a => a -> Vec k a -> Vec k a
scale t = map (\x -> t * x)

matvec : { m, n, a } (Dim m, Dim n, Elem a, Ring ([m]a)) => Mat m n a -> Vec n a -> Vec m a
matvec M v = sum (zipWith scale v (transpose M))

matmul : { m, k, n, a } (Dim m, Dim k, Dim n, Elem a, Ring ([m]a)) => Mat m k a -> Mat k n a -> Mat m n a
matmul A B = transpose (zipWith matvec (repeat A) (transpose B))

// Matrix views

flatten : { m, n, a } (Dim m, Dim n) => Mat m n a -> Vec (m*n) a
flatten = join 

unflatten : { m, n, a } (Dim m, Dim n) => Vec (m*n) a -> Mat m n a
unflatten = groupBy

reshape : { p, q, m, n, a } (Dim m, Dim n, Dim p, Dim q, m*n == p*q) => Mat m n a -> Mat p q a
reshape M = unflatten (flatten M)

// The main reason for exploring matrix operations in Cryptol is its dependent type system.
// We can express dimension requirements in function signatures, surfacing shape mismatches as compiler errors.
// And so a matmul between a 3x4 and 4x5 matrix typechecks:

wellFormedMatmul = matmul (zeros`{3,4}) (zeros`{4,5})

// But a 3x4 and a 3x3 doesn't:

/*

malformedMatmul = matmul (zeros`{3,4}) (zeros`{3,3})

// yields:
// [error] at main.cry:62:41--62:46:
//   Type mismatch:
//     Expected type: 4
//     Inferred type: 3
//     Context: [ERROR] _
//     When checking type of function argument

*/

// We can also express more complicated requirements. For instance, that reshape preserves element count. So this works:

reshaped = reshape`{3,2} [[1,2,3],
                          [4,5,6]]

// yields:
// [[1,2],
//  [3,4],
//  [5,6]]

// But this fails to typecheck:

/*

misshaped = reshape`{3,3} [[1,2,3],
                           [4,5,6]]

// yields:
// [error] at main.cry:88:1--89:36:
//   â€¢ Unsolvable constraint:
//       6 == 9
//         arising from
//         use of expression reshape
//         at main.cry:88:13--88:20

*/

// For reference, let's implement a dense (fully connected) neural network layer.

relu : { a } (Literal 0 a, Cmp a) => a -> a
relu x = if x > 0 then x else 0

dense : { batch_size, input_size, units } (Dim batch_size, Dim input_size, Dim units) 
    => Mat input_size units Float32      // Weights matrix
    -> Vec units Float32                 // Bias vector
    -> Mat batch_size input_size Float32 // Input matrix
    -> Mat batch_size units Float32      // Output matrix
dense W b x = map (map relu) ((matmul x W) + repeat b)

// Compute a forward pass through the dense layer with some arbitrary inputs 
out = dense W b x
    where
        x = [[1,2,3],
             [4,5,6]]

        b = [-20,-10,0,10,20]

        W = unflatten [ i /. 10 | i <- [1 .. 15]]
